{"version":3,"sources":["components/model.js","components/WebcamCapture.js","components/controller.js","components/snake.js","App.js","reportWebVitals.js","index.js"],"names":["defineModel","model","tf","add","dense","units","inputShape","activation","compile","loss","softmaxCrossEntropy","optimizer","adam","metrics","summary","preProcess","image","mobilenet","a","infer","postProcess","oneHotPrediction","argMax","data","predict","predictionArray","mobilenetOutput","predictionIndex","prediction","getTensorsAndTargets","state","tensorsTargets","up","infer_up","down","infer_down","left","infer_left","right","infer_right","tensors","reshape","targets","fitModel","console","log","fit","epochs","history","print","run_tf","control","controlPrediction","t","connect","props","webcamRef","useRef","id","useState","imgSrc","setImgSrc","showImg","setShowImg","isController","current","rerender","setRerender","loadImg","url","img","Image","crossOrigin","src","height","width","tensor","fromPixels","dispatch","type","imageSrc","getScreenshot","useEffect","setTimeout","models","hasOwnProperty","captureWebcam","capture","useCallback","e","ref","mirrored","screenshotFormat","videoConstraints","alt","onClick","style","trainingInProgress","action","load_mobilenet","trainDispatchModels","cameraBlock","display","position","top","bottom","containerStyle","positionRange","Array","from","parseInt","keys","map","x","score","setScore","snakeTop","setSnakeTop","snakeLeft","setSnakeLeft","dotLeft","setDotLeft","dotTop","setDotTop","tailLength","lastPositions","snakeDirection","setSnakeDirection","setDotPosition","Math","floor","random","length","randomTop","randomLeft","checkDotCollision","abs","tempScore","latestFrame","gameLoop","setDirection","tailPositions","slice","forEach","pos","alert","checkTailCollision","min","max","setInterval","play","grid","border","margin","snakeBase","backgroundColor","backgroundSize","snake","dot","justifyContent","className","indexOf","App","class","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","store","createStore","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.a4ea0820.chunk.js","sourcesContent":["import * as tf from \"@tensorflow/tfjs\";\nimport * as mobilenet from \"@tensorflow-models/mobilenet\";\n\nfunction defineModel() {\n    const model = tf.sequential();\n    // model.add(tf.layers.dense({units: 1, inputShape: [1]}));\n    // model.add(tf.layers.conv2d({kernelSize: 3, filters: 4, strides: 1, padding: \"same\", inputShape: [200, 200, 3]}))\n    // model.add(tf.layers.reLU())\n    // model.add(tf.layers.conv2d({kernelSize: 3, filters: 4, strides: 1, padding: \"same\"}))\n    // model.add(tf.layers.reLU())\n    // model.add(tf.layers.conv2d({kernelSize: 3, filters: 4, strides: 1, padding: \"same\"}))\n    // model.add(tf.layers.reLU())\n    // model.add(tf.layers.conv2d({kernelSize: 3, filters: 4, strides: 1, padding: \"same\"}))\n    // model.add(tf.layers.reLU())\n    // model.add(tf.layers.flatten())\n    model.add(tf.layers.dense({ units: 1024, inputShape: [1024] }))\n    // model.add(tf.layers.dense({units: 500}))\n    // model.add(tf.layers.dense({units: 200}))\n    model.add(tf.layers.dense({ units: 4 }))\n    model.add(tf.layers.activation({ activation: \"softmax\" }))\n    model.compile({ loss: tf.losses.softmaxCrossEntropy, optimizer: tf.train.adam(0.0001), metrics: ['accuracy'] });\n    model.summary()\n    return model\n}\n\nasync function preProcess(image, mobilenet) {\n    let infer = await mobilenet.infer(image, true)\n    return infer\n}\n\nasync function postProcess(oneHotPrediction) {\n    return await oneHotPrediction.argMax(1).data()\n}\n\nexport async function predict(image, model, mobilenet) {\n    const predictionArray = [\"up\", \"down\", \"left\", \"right\"]\n    let mobilenetOutput = await preProcess(image, mobilenet)\n    let oneHotPrediction = await model.predict(mobilenetOutput)\n    let predictionIndex = await postProcess(oneHotPrediction)\n    let prediction = predictionArray[predictionIndex]\n    return prediction\n}\n\nasync function getTensorsAndTargets(state, mobilenet) {\n    let tensorsTargets = {}\n\n    let infer_up = await mobilenet.infer(state.up, true);\n    let infer_down = await mobilenet.infer(state.down, true);\n    let infer_left = await mobilenet.infer(state.left, true);\n    let infer_right = await mobilenet.infer(state.right, true);\n\n    // console.log(\"states\");\n    // tf.max(state.up).print()\n    // tf.max(state.up).print()\n    // tf.max(state.down).print()\n    // tf.max(state.left).print()\n    // tf.max(state.right).print()\n    // console.log(\"infers\");\n    // tf.max(infer_up).print()\n    // tf.max(infer_up).print()\n    // tf.max(infer_down).print()\n    // tf.max(infer_left).print()\n    // tf.max(infer_right).print()\n\n    tensorsTargets.tensors = tf.concat([infer_up, infer_down, infer_left, infer_right])\n    tensorsTargets.tensors = tensorsTargets.tensors.reshape([4, 1024])\n    // tensorsTargets.tensors = tf.concat([state.up, state.down, state.left, state.right])\n    // tensorsTargets.tensors = tensorsTargets.tensors.reshape([4, 200, 200, 3])\n    tensorsTargets.targets = tf.tensor([0, 1, 2, 3], [4], \"int32\")\n    tensorsTargets.targets = tf.oneHot(tensorsTargets.targets, 4)\n    return tensorsTargets\n}\n\nasync function fitModel(model, tensorsTargets) {\n    // Train the model using the data.\n    console.log(\"training network\")\n    const history = await model.fit(tensorsTargets.tensors, tensorsTargets.targets, { epochs: 10 })\n    console.log(\"history: \", history)\n    console.log(\"finished training\")\n    let predictions = model.predict(tensorsTargets.tensors);\n    predictions.print()\n}\n\nexport async function run_tf(state, mobilenet) {\n    mobilenet = await mobilenet\n    let model = defineModel()\n    let tensorsTargets = await getTensorsAndTargets(state, mobilenet)\n    await fitModel(model, tensorsTargets)\n    let controlPrediction = model.predict(\n        await preProcess(state.control, mobilenet)\n    )\n    controlPrediction.print()\n    let t = await postProcess(controlPrediction)\n    console.log([\"up\", \"down\", \"left\", \"right\"][t]);\n    return {\n        mobilenet: mobilenet, \n        model: model\n    }\n}\n\nexport async function load_mobilenet() {\n    return await mobilenet.load()\n}","import Webcam from \"react-webcam\";\nimport * as tf from '@tensorflow/tfjs';\n\nimport React, { useCallback, useRef, useState, useEffect } from \"react\";\nimport { connect } from \"react-redux\";\nimport { predict } from \"./model\";\n\n\nfunction WebcamCapture(props) {\n    const webcamRef = useRef(null);\n    const id = useRef(props.id);\n    let [imgSrc, setImgSrc] = useState(null);\n    let height = 200;\n    let width = 200;\n    let [showImg, setShowImg] = useState(false);\n    const isController = useRef(id.current === \"controller\")\n    let [rerender, setRerender] = useState(true)\n\n    async function loadImg(url) {\n        let img = new Image()\n        img.crossOrigin = 'anonymous'\n        img.src = url\n        img.height = height\n        img.width = width\n        img = await img\n        let tensor = tf.browser.fromPixels(img)\n        // tf.max(tensor).print()\n        // tensor.print()\n        props.dispatch({\n            type: id.current,\n            tensor: tensor\n        })\n        // return tensor\n    }\n\n    useEffect(() => {\n        if (isController.current) {\n            let imageSrc = webcamRef.current.getScreenshot();\n            loadImg(imageSrc);\n        }\n    }, [])\n\n    async function captureWebcam() {\n        let imageSrc = webcamRef.current.getScreenshot();\n        let image = await loadImg(imageSrc);\n    }\n\n    useEffect(() => {\n        setTimeout(() => {\n            if (isController.current && props.state.models?.hasOwnProperty(\"model\")) {\n                captureWebcam()\n            }\n            setRerender(!rerender)\n        }, 350)\n    }, [rerender])\n\n    const capture = useCallback((e) => {\n        if (!showImg) {\n            // console.log(id)\n            let imageSrc = webcamRef.current.getScreenshot();\n            loadImg(imageSrc)\n            // let img = new Image()\n            // img.height = height\n            // img.width = width\n            // img.crossOrigin = 'anonymous'\n            // img.src = imageSrc\n            // let tensor = tf.browser.fromPixels(img)\n            // tf.max(tensor).print()\n            // props.dispatch({\n            //     type: id.current,\n            //     tensor: tensor\n            // })\n            setImgSrc(imageSrc);\n            setShowImg(true);\n        } else {\n            setImgSrc(null);\n            setShowImg(false);\n        }\n    })\n\n    return (\n        <>\n            {!showImg && (<Webcam\n                id={id}\n                ref={webcamRef}\n                mirrored={true}\n                screenshotFormat=\"image/jpeg\"\n                videoConstraints={{\n                    height: height,\n                    width: width\n                }}\n            />)}\n            {showImg && (\n                <img\n                    id=\"img\"\n                    src={imgSrc}\n                    alt=\"\"\n                />\n            )}\n            {!isController.current && (<button onClick={capture} style={{\n                height: \"30px\"\n            }}>Capture\n            </button>)}\n        </>\n    );\n}\n\nconst mapStateToProps = (state) => ({\n    state: state\n})\n\nexport default connect(mapStateToProps)(WebcamCapture);","import React, { useRef, useEffect, useState } from \"react\";\nimport WebcamCapture from './WebcamCapture';\nimport { connect } from \"react-redux\";\nimport { load_mobilenet, run_tf } from \"./model\";\nimport userEvent from \"@testing-library/user-event\";\n\n\n\nfunction Controller(props) {\n    let trainingInProgress = useRef(false)\n    let [rerender, setRerender] = useState(true)\n    let mobilenet = useRef({})\n    \n    useEffect(() => {\n        mobilenet.current = load_mobilenet()\n    }, [])\n\n    const check_images = () => {\n        return !!(props.state.hasOwnProperty(\"up\")\n            && props.state.hasOwnProperty(\"down\")\n            && props.state.hasOwnProperty(\"left\")\n            && props.state.hasOwnProperty(\"right\"));\n    }\n\n    useEffect(() => {\n        setTimeout(() => {\n            setRerender(!rerender)\n        }, 1000)\n    }, [rerender])\n\n    async function trainDispatchModels() {\n        let models = await run_tf(props.state, mobilenet.current)\n        props.dispatch({\n            type: \"models\",\n            models: models\n        })\n        props.dispatch({\n            type: \"play\",\n            action: true\n        })\n    }\n\n    let images_exist = check_images()\n    if (images_exist && !trainingInProgress.current) {\n        trainingInProgress.current = true;\n        trainDispatchModels()\n    }\n\n    const controlContainer = {\n        display: \"grid\",\n        position: \"relative\",\n        width: \"600px\",\n        height: \"463px\",\n    };\n    const cameraBlock = {\n        display: \"grid\",\n        position: \"absolute\"\n    }\n    return (\n        <div>\n            <h3>Controls</h3>\n            <div style={controlContainer}>\n                <div style={{ ...cameraBlock, top: \"0\", left: \"33.5%\" }}>\n                    <WebcamCapture id=\"up\" />\n                </div>\n                <div style={{ ...cameraBlock, bottom: \"0\", left: \"0%\" }}>\n                    <WebcamCapture id=\"left\" />\n                </div>\n                <div style={{ ...cameraBlock, bottom: \"0\", right: \"0%\" }}>\n                    <WebcamCapture id=\"right\" />\n                </div>\n                <div style={{ ...cameraBlock, bottom: \"6.6%\", left: \"33.5%\" }}>\n                    <WebcamCapture id=\"controller\" />\n                </div>\n                <div style={{ ...cameraBlock, bottom: \"-50%\", left: \"33.5%\" }}>\n                    <WebcamCapture id=\"down\" />\n                </div>\n                <div style={{ ...cameraBlock, top: \"-20%\", left: \"-10%\" }}>\n                </div>\n            </div>\n        </div>\n    );\n}\n\n\nconst mapStateToProps = (state) => ({\n    state: state\n})\n\n\nexport default connect(mapStateToProps)(Controller)","import React, { useEffect, useRef, useState } from \"react\";\nimport { connect } from \"react-redux\";\nimport { predict } from \"./model\";\n\nfunction Snake(props) {\n\n    const containerStyle = {\n        height: \"1000px\",\n        width: \"1000px\"\n    }\n    const positionRange = Array.from(Array(parseInt(containerStyle.height) / 20).keys()).map(x => x * 20)\n    const getRandomPosition = () => {\n        let randomTopPosition = positionRange[Math.floor(Math.random() * positionRange.length)]\n        let randomLeftPosition = positionRange[Math.floor(Math.random() * positionRange.length)]\n        return [randomTopPosition, randomLeftPosition]\n    }\n\n    let [score, setScore] = useState(0)\n    let [snakeTop, setSnakeTop] = useState(0)\n    let [snakeLeft, setSnakeLeft] = useState(0)\n    let [dotLeft, setDotLeft] = useState(0)\n    let [dotTop, setDotTop] = useState(0)\n    let tailLength = useRef(0)\n    let lastPositions = useRef([])\n    let [snakeDirection, setSnakeDirection] = useState(\"down\")\n\n    let [rerender, setRerender] = useState(true)\n\n\n    function moveSnake() {\n        if (snakeDirection === \"down\") {\n            snakeTop = snakeTop + 20\n        } else if (snakeDirection === \"up\") {\n            snakeTop = snakeTop - 20\n        } else if (snakeDirection === \"left\") {\n            snakeLeft = snakeLeft - 20\n        } else if (snakeDirection === \"right\") {\n            snakeLeft = snakeLeft + 20\n        }\n        if (snakeTop > 980 || snakeTop < 0) {\n            snakeTop = 980 - Math.min(Math.max(snakeTop, 0), 980)\n        }\n        if (snakeLeft > 980 || snakeLeft < 0) {\n            snakeLeft = 980 - Math.min(Math.max(snakeLeft, 0), 980)\n        }\n        setSnakeTop(() => snakeTop)\n        setSnakeLeft(() => snakeLeft)\n        lastPositions.current = [{\n            top: snakeTop,\n            left: snakeLeft\n        }, ...lastPositions.current]\n        lastPositions.current.length = tailLength.current + 1\n    }\n\n    function setDotPosition() {\n        let [randomTop, randomLeft] = getRandomPosition()\n        dotTop = randomTop\n        dotLeft = randomLeft\n        setDotTop(() => randomTop)\n        setDotLeft(() => randomLeft)\n    }\n\n    function checkDotCollision() {\n        if (Math.abs(dotTop - snakeTop) === 0 && Math.abs(dotLeft - snakeLeft) === 0) {\n            setDotPosition()\n            tailLength.current = tailLength.current + 1\n            updateScore()\n        }\n    }\n\n    function checkTailCollision() {\n        let tailPositions = lastPositions.current\n        tailPositions = tailPositions.slice(1, tailPositions.length)\n        tailPositions.forEach((pos) => {\n            // console.log(pos, snakeTop, snakeLeft)\n            if (Math.abs(pos.top - snakeTop) === 0 && Math.abs(pos.left - snakeLeft) === 0) {\n                alert(\"Snake is eating itself!!\")\n            }\n        })\n    }\n\n    async function setDirection() {\n        let models = props.state.models\n        let latestFrame = props.state.control\n        let prediction = await predict(latestFrame, models.model, models.mobilenet)\n        // console.log(prediction);\n        setSnakeDirection(prediction)\n    }\n\n    function updateScore() {\n        setScore((tempScore) => tempScore + 1)\n    }\n\n    function gameLoop() {\n        setDirection()\n        checkTailCollision()\n        moveSnake()\n        checkDotCollision()\n    }\n\n    useEffect(() => {\n        setDotPosition()\n        setInterval(() => {\n            // if (props.state.play) {\n            //     gameLoop()\n            // }\n        }, 70)\n    }, [])\n\n    useEffect(() => {\n        setTimeout(() => {\n            if (props.state.play) {\n                gameLoop()\n            }\n            setRerender(!rerender)\n            // console.log(props.state);\n        }, 150)\n    }, [rerender])\n\n    // function spacebarPressed(e) {\n    //     if (e.code === \"ArrowUp\" && snakeDirection !== \"down\") {\n    //         snakeDirection = \"up\"\n    //         setSnakeDirection(snakeDirection);\n    //     } else if (e.code === \"ArrowDown\" && snakeDirection !== \"up\") {\n    //         snakeDirection = \"down\"\n    //         setSnakeDirection(snakeDirection);\n    //     } else if (e.code === \"ArrowLeft\" && snakeDirection !== \"right\") {\n    //         snakeDirection = \"left\"\n    //         setSnakeDirection(snakeDirection);\n    //     } else if (e.code === \"ArrowRight\" && snakeDirection !== \"left\") {\n    //         snakeDirection = \"right\"\n    //         setSnakeDirection(snakeDirection);\n    //     }\n    // }\n\n    // window.addEventListener(\"keydown\", spacebarPressed)\n\n    // const [fakeCurrentDate, setFakeCurrentDate] = useState(new Date()) // default value can be anything you want\n\n    // useEffect(() => {\n    //     setTimeout(() => setFakeCurrentDate(new Date()), 1000)\n    // }, [fakeCurrentDate])\n\n    const grid = {\n        width: containerStyle.width,\n        height: containerStyle.height,\n        position: \"relative\",\n        border: \"1px solid brown\",\n        margin: \"auto\",\n    };\n    const snakeBase = {\n        width: \"20px\",\n        height: \"20px\",\n        backgroundColor: \"red\",\n        backgroundSize: \"20px 20px\",\n        position: \"absolute\",\n    };\n    const snake = {\n        width: \"20px\",\n        height: \"20px\",\n        backgroundColor: \"green\",\n        backgroundSize: \"20px 20px\",\n        position: \"absolute\",\n        top: `${snakeTop}px`,\n        left: `${snakeLeft}px`\n    };\n    const dot = {\n        width: \"20px\",\n        height: \"20px\",\n        backgroundColor: \"blue\",\n        backgroundSize: \"20px 20px\",\n        position: \"absolute\",\n        top: `${dotTop}px`,\n        left: `${dotLeft}px`\n    }\n    const scoreStyle = {\n        display: \"flex\",\n        justifyContent: \"center\"\n    }\n\n    return (\n        <div>\n            <h1 id=\"score\" style={scoreStyle}>Score: {score}</h1>\n            <div className=\"grid\" id=\"grid\" style={grid}>\n                <div className=\"snake\" id=\"snake\" style={snake} />\n                {lastPositions.current.map((pos) => {\n                    return <div style={{\n                        ...snakeBase,\n                        top: `${pos.top}px`,\n                        left: `${pos.left}px`\n                    }} key={lastPositions.current.indexOf(pos)} />\n                })}\n                <div className=\"dot\" id=\"dot\" style={dot} />\n            </div>\n            {/* <h2>{fakeCurrentDate.toString()}</h2> */}\n        </div>\n    );\n}\n\nconst mapStateToProps = (state) => ({\n    state: state\n})\n\nexport default connect(mapStateToProps)(Snake)","import './App.css';\n\nimport React from \"react\";\nimport Controller from './components/controller';\nimport Snake from './components/snake';\n\n\nfunction title() {\n    return (\n        <div>\n            <h1>Snake Game!</h1>\n            {/*<p>With some interesting Controllers</p>*/}\n        </div>\n    )\n}\n\nfunction App() {\n    return (\n        <div className=\"App\">\n            <header className=\"App-header\">\n                <div>{title()}</div>\n                {/* eslint-disable-next-line react/style-prop-object */}\n                <div class=\"container\">\n                    <Snake/>\n                    <Controller/>\n                </div>\n            </header>\n        </div>\n    );\n}\n\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nimport { createStore } from \"redux\";\nimport { Provider } from \"react-redux\";\n\nconst reducer = (state, action) => {\n    switch (action.type) {\n        default:\n            state.control = action.tensor\n            break;\n        case \"up\":\n            state.up = action.tensor\n            break;\n        case \"down\":\n            state.down = action.tensor\n            break;\n        case \"left\":\n            state.left = action.tensor\n            break;\n        case \"right\":\n            state.right = action.tensor\n            break\n        case \"models\":\n            state.models = action.models\n            break\n        case \"play\":\n            state.play = action.action\n            break\n    }\n    return state\n}\n\nconst store = createStore(reducer, {})\n\nReactDOM.render(\n    <React.StrictMode>\n        <Provider store={store}>\n            <App />\n        </Provider>\n    </React.StrictMode>,\n    document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals()"],"sourceRoot":""}